# 三次握手&四次挥手

## TCP报文格式

![TCP报文格式](http://ph3k80bwz.bkt.clouddn.com/TCP.png)

每个字段的介绍

- 源端口：源端口和ip地址的作用是表示报文的返回地址
- 目的端口：端口知名接收方计算机上的应用程序连接

`TCP报文头中的源端口号和目的端口号同IP数据报中的源ip与目的ip唯一确定一条TCP连接`

- 序号：`Seq`序号,占32位，`用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记`
- 确认序号：Ack序号，占32位，`只有ACK标志位置为1时，确认序号字段才有效`。并且`Ack=Seq+1`。
- 首部长度/数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8=60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度`实际上指示了数据区在报文段中的起始偏移值`。
- 标志位:一共有6个，即`URG,ACK,PSH,RST,SYN,FIN`具体含义
> - URG：紧急指针（urgent pointer）有效。
> - ACK：确认序号有效
> - PSH：接收方应该尽快将这个报文交给应用层。
> - RST：重置连接。
> - SYN：发起一个新连接。
> - FIN：释放一个连接。

## 三次握手

![三次握手](https://upload-images.jianshu.io/upload_images/8736995-56ec2a6ac0983587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

以客户端和服务端为例

- 第一次握手：客户端发送一个包SYN(SYN=1,Seq序号为一个随机值，假设为x)到服务器，等待服务器进行确认。
- 第二次握手，服务器端接收到客户端发送的SYN包，确认用户的SYN包信息，并且确认序号Ack变为x+1,ACK控制为变为1，并且自己也会发送一个SYN包(设置SYN=1,并且Seq序号也是随机设定的)，因此本次会发送`SYN+ACK`包
- 客户端接收`SYN+ACK`包，向服务器发送确认包ACK(`Ack=y+1，Seq为上一次Seq的随机值+1`)此包发送完毕，服务端和客户端建立连接，完成三次握手，在三次握手的的过程中，是不携带数据的，并且三次握手之后，ACk控制位将一直置为1。

### 为什么建立连接的时候是三次握手呢？

采用三次握手是为了防止失效的连接请求报文段突然又传到设备，因而产生错误。`失效的连接请求报文段是指：设备1向设备2发起一个请求，但是设备2并没有得到确认，于是经过一段时间后，设备1又向设备2发送请求，并且建立成功，顺序完成数据传输`这样第一次发送的请求报文，并没有得到设备2的响应，这样我们就将其视为失效请求.在三次握手中，我们两个设备之间都有一个发送SYN和接收ACK的过程双方都是发送之后能接收， 表明通信正常，准备工作ok.

## 四次挥手

![四次挥手](https://upload-images.jianshu.io/upload_images/8736995-98c0a48e808ea493.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 第一次挥手：设备A发起发送一个报，里面（FIN控制为设为1，Seq等于上一次传过来的数据的最后一个字节序号+1），用来表示关闭一个连接，也就是告诉设备B：“我不会给你再发东西了”
- 第二次挥手:设备B接收到FIN为1这个包之后，确认序号+1,将ACK控制位置为1,并且Seq序号也为设备B上一次发送的序号数+1。
- 第三次挥手：设备B发送一个FIN，用来关闭设备B到设备A的数据传送，告诉A,我的数据发送完了，不会再给你发送数据了。
- 第四次挥手：设备A接收到这个包之后，还会发送一个ACK给关闭方，确认序号为收到的序号+1，注意此时TCP连接还没有释放，必须经历过2*MSL的时间后，当设备撤销相应的TCB之后，才会CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。至此，完成四次挥手。

### 为什么客户端最后还需要等待2MSL？

- 保证最后一个ACK报文能够到达服务器，因为这个ACK可能会丢失，站在服务器端的角度上，，我已经发送FIN和ACK请求断开了，但是客户端还没有响应。而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
- 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

### 为什么建立连接的时候是三次握手，而关闭连接的时候是四次挥手？

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。