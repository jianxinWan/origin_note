# HTTP 常用状态码以及浏览器缓存

## 状态码的分类

- 1.xx 信息响应类，表示接收到请求并且继续处理
- 2.xx 处理成功相应类，表示动作被成功接收、理解和接收
- 3.xx 重定向类，为了完成指定动作必须做相应处理
- 4.xx 客户端错误，客户端的请求包含语法错误或者不能正确执行
- 5.xx 服务器错误，服务器不能正确执行的请求

整个网络请求大概是这样一个过程

![网络请求](http://ph3k80bwz.bkt.clouddn.com/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82.png)

我们总结一些比较重要的状态码

状态码|含义
---:|:---
100|客户端应当继续发送请求
200|表示请求已成功，请求希望的响应头或者数据体随此相应返回。
304|如果客户端发送一个带条件的GET请求且请求已被允许，而文档的内容(自上次访问以来或者根据请求的条件)`并没有改变`,则服务器返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。并且请求头必须包含以下的头信息。`Date`除非这个服务器没有时钟，加入没有时钟的服务器也遵循这个规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去，缓存机制就会正常工作。`Etag和/或Content-Location`加入同样的请求体本应该返回200响应。`Expries，Cache-Control和/或Vary`，假如其值可能与之前相同变量的其他响应对应的值不同的话，例如本相应请求中使用了强制缓存验证，那么本次响应中不应该包含其他实体头，否则（例如，某个带条件的GET请求使用了弱缓存验证）本次响应禁止包含其它实体头，这避免了缓存了的实体内容和更新了的实体内容和更新了的实体头信息之间的不一致。假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须护士这个响应，并且重新发送不包含的限制条件的请求，加入收到的一个要求更新某个缓存目的304响应，那么缓存系统碧玺更新整个条目以反应所有响应中被更新的字段的值。
400|语义有误，请求参数错误
401|当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 `WWW-Authenticate` 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 `Authorization` 头信息的请求。如果当前请求已经包含了 `Authorization` 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息
403|服务器已经理解这个请求，但是拒绝访问
404|请求失败，找不到，请求希望得到的资源未被在服务器上发现。
405|请求方法错误
500|服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在`服务器的程序码出错时出现`。

## 304状态码的详解

### 是否禁止缓存

`禁止缓存`指的是缓存中不得存储任何关于客户端请求和服务器端响应的内容。每次客户端发起的请求都会下载完成的响应内容。

设置方法`Cache-Control：no-store`与`Pragm:no-cache`都可以禁止缓存

但是两者也有区别，`Pragm`可以兼容http1.0和http1.1,而`Cache-control只是http1.1提供的`

### 是否检查本地是否过期

检查本地是否过期主要由`Cache-Control`中的`no-cache`和`must-revalidate`这两个值可选控制

> - no-cache；告诉浏览器，缓存服务器，不管本地是否过期，使用资源副本前，一定要到源服务器进行副本有效性检测
> - must-revalidate；告诉浏览器，缓存服务器，使用资源副本前，可以使用本地副本；本地副本一旦过期，必须去，源服务器进行有效性检测

### 本地副本过期检查机制

- 过期机制中最主要的指令就是`max-age:<seconds>`，他表示资源能够被缓存的最大时间，通常会和`must-revalidate`一起使用，使用起来就像下面这样。

```js
Cache-Control:max-age:60;must-revalidate;
```

- 如果不包含`max-age属性`，则会去查看是否包含`Expires`属性，通过比较`Expires`的值和里面的Date属性的值来判断缓存是否还有效。

- 如果max-age和expires属性都没有，找找头里的`Last-Modified`信息，如果有，缓存的寿命就等于头部中的`Date`的值减去`Last-Modified`的值除以10

本地没有过期时，则会直接从缓存中读取资源，并返回200的状态码。

### 源服务器进行有效性检测

服务器端响应头：Last-Modified,Etag
浏览器请求头：if-Modified-Since,if-None-Match

`Last-Modified/if-Modified-Since`

Last-Modified是响应头，If-Modified-Since是请求头。Last-Modified把Web组件的最后修改时间告诉客
户端，客户端在下次请求此Web组件的时候，会把上次服务端响应的最后修改时间作为If-Modified-Since
的值发送给服务器，服务器可以通过这个值来判断是否需要重新发送，如果不需要，就简单的发送一个
304状态码，客户端将从缓存里直接读取所需的Web组件。如果有更新，返回HTTP 200和更新的页面内容，
并且携带新的”ETag”和”LastModified”

使用这个机制，能够避免重复发送文件给浏览器，不过仍然会产生一个HTTP请求。

`ETag / If-None-Match`

ETag是响应头，If-None-Match是请求头。Last-Modified / If-Modified-Since的主要缺点就是它只能精确到秒的级别，一旦在一秒的时间里出现了多次修改，那么Last-Modified / If-Modified-Since是无法体现的。相比较，ETag / If-None-Match没有使用时间作为判断标准，而是使用一个特征串。Etag把Web组件的特征串告诉客户端，客户端在下次请求此Web组件的时候，会把上次服务端响应的特征串作为If-None-Match的值发送给服务端，服务端可以通过这个值来判断是否需要从重新发送，如果不需要，就简单的发送一个304状态码，客户端将从缓存里直接读取所需的Web组件。因此，HTTP/1.1利用Entity Tag头提供了更加严格的验证。

当服务器发出响应的时候，可以通过两种方式来告诉客户端缓存请求

## 参考链接

[理解浏览器缓存以及304状态码](https://juejin.im/post/5a142fab6fb9a044fb076322)
[HTTP 状态码详解与选用](https://segmentfault.com/a/1190000006058316)