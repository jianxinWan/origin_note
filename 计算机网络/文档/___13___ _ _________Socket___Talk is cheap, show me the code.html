<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="demo.css">
</head>
<body>
  <h1>第13讲 | 套接字Socket：Talk is cheap, show me the code</h1>
  <div data-v-87ffcada="" class="article"><!----> <div data-v-87ffcada="" class="main main-app"><div data-v-87ffcada="" class="breadcrumb breadcrumb pd"><span><a href="/" class="title router-link-active">讲堂</a> <span class="split iconfont"></span></span><span><a href="/column/85" class="title">趣谈网络协议</a> <span class="split iconfont"></span></span><span><span class="title">文章详情</span> <!----></span></div> <h1 data-v-87ffcada="" class="article-title pd">
      第13讲 | 套接字Socket：Talk is cheap, show me the code
    </h1> <div data-v-87ffcada="" class="article-info pd"><span data-v-87ffcada="">2018-06-15</span> <span data-v-87ffcada="">刘超</span></div> <div data-v-87ffcada="" class="article-content typo common-content pd"><img data-v-87ffcada="" src="https://static001.geekbang.org/resource/image/a9/c6/a9b6972262137a72fdaa0d06916ac0c6.jpg"> <!----> <div data-v-87ffcada="" class="mini-audio-player"><a href="javascript:;" class="btn-play"></a> <div class="audio-info"><h3>第13讲 | 套接字Socket：Talk is cheap, show me the code</h3> <p><span>朗读人：刘超&nbsp;&nbsp;&nbsp;</span> <span>19′42′′ | 7.95M</span></p></div> <!----> <audio title="第13讲 | 套接字Socket：Talk is cheap, show me the code" src="https://res001.geekbang.org/media/audio/75/6f/75b47bb7d89a675b096c50ed84d2da6f/ld/ld.m3u8"></audio></div> <div data-v-87ffcada="" id="article-content" class=""><div class="text"><p>前面讲完了 TCP 和 UDP 协议，还没有上手过，这一节咱们讲讲基于 TCP 和 UDP 协议的 Socket 编程。</p>
<p>在讲 TCP 和 UDP 协议的时候，我们分客户端和服务端，在写程序的时候，我们也同样这样分。</p>
<p>Socket 这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个 Socket。</p>
<p>在建立 Socket 的时候，应该设置什么参数呢？Socket 编程进行的是端到端的通信，往往意识不到中间经过多少局域网，多少路由器，因而能够设置的参数，也只能是端到端协议之上网络层和传输层的。</p>
<p>在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p>
<h2 id="-tcp-socket-">基于 TCP 协议的 Socket 程序函数调用过程</h2>
<p>两端创建了 Socket 之后，接下来的过程中，TCP 和 UDP 稍有不同，我们先来看 TCP。</p>
<p>TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。为什么需要端口呢？要知道，你写的是一个应用程序，当一个网络包来的时候，内核要通过 TCP 头里面的这个端口，来找到你这个应用程序，把包给你。为什么要 IP 地址呢？有时候，一台机器会有多个网卡，也就会有多个 IP 地址，你可以选择监听所有的网卡，也可以选择监听一个网卡，这样，只有发给这个网卡的包，才会给你。</p><!-- [[[read_end]]] -->
<p>当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。</p>
<p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p>
<p>接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。</p>
<p>在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。</p>
<p>这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作<strong>监听 Socket</strong>，一个叫作<strong>已连接 Socket</strong>。</p>
<p>连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<p>这个图就是基于 TCP 协议的 Socket 程序函数调用过程。</p>
<p> <img src="https://static001.geekbang.org/resource/image/77/92/77d5eeb659d5347874bda5e8f711f692.jpg" alt=""></p>
<p>说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p>
<p>在内核中，Socket 是一个文件，那对应就有文件描述符。每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标。</p>
<p>这个数组中的内容是一个指针，指向内核中所有打开的文件的列表。既然是一个文件，就会有一个 inode，只不过 Socket 对应的 inode 不像真正的文件系统一样，保存在硬盘上的，而是在内存中的。在这个 inode 中，指向了 Socket 在内核中的 Socket 结构。</p>
<p>在这个结构里面，主要的是两个队列，一个是<strong>发送队列</strong>，一个是<strong>接收队列</strong>。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构。看到这个，是不是能和前面讲过的收发包的场景联系起来了？</p>
<p>整个数据结构我也画了一张图。</p>
<p><img src="https://static001.geekbang.org/resource/image/60/8c/602d09290bd4f9e0183f530e9653348c.jpg" alt="">  </p>
<h2 id="-udp-socket-">基于 UDP 协议的 Socket 程序函数调用过程</h2>
<p>对于 UDP 来讲，过程有些不一样。UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是，UDP 的的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。</p>
<p>这个图的内容就是基于 UDP 协议的 Socket 程序函数调用过程。</p>
<p><img src="https://static001.geekbang.org/resource/image/77/ef/778687d1a02ffc0c24078c33be2ac1ef.jpg" alt="">﻿﻿</p>
<h2 id="-">服务器如何接更多的项目？</h2>
<p>会了这几个基本的 Socket 函数之后，你就可以轻松地写一个网络交互的程序了。就像上面的过程一样，在建立连接后，进行一个 while 循环。客户端发了收，服务端收了发。</p>
<p>当然这只是万里长征的第一步，因为如果使用这种方法，基本上只能一对一沟通。如果你是一个服务器，同时只能服务一个客户，肯定是不行的。这就相当于老板成立一个公司，只有自己一个人，自己亲自上来服务客户，只能干完了一家再干下一家，这样赚不来多少钱。</p>
<p>那作为老板你就要想了，我最多能接多少项目呢？当然是越多越好。</p>
<p>我们先来算一下理论值，也就是<strong>最大连接数</strong>，系统会用一个四元组来标识一个 TCP 连接。</p>
<pre style="position: relative;"><code><table class="hljs-ln"><tbody><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">{本机 IP, 本机端口, 对端 IP, 对端端口}</div></td></tr></tbody></table></code><div class="richcontent-pre-copy"><span class="iconfont"></span>复制代码</div></pre><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。因此，服务端端 TCP 连接四元组中只有对端 IP, 也就是客户端的 IP 和对端的端口，也即客户端的端口是可变的，因此，最大 TCP 连接数 = 客户端 IP 数×客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是<strong>文件描述符限制</strong>，按照上面的原理，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是<strong>内存</strong>，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。</p>
<p>所以，作为老板，在资源有限的情况下，要想接更多的项目，就需要降低每个项目消耗的资源数目。</p>
<h3 id="-">方式一：将项目外包给其他公司（多进程方式）</h3>
<p>这就相当于你是一个代理，在那里监听来的请求。一旦建立了一个连接，就会有一个已连接 Socket，这时候你可以创建一个子进程，然后将基于已连接 Socket 的交互交给这个新的子进程来做。就像来了一个新的项目，但是项目不一定是你自己做，可以再注册一家子公司，招点人，然后把项目转包给这家子公司做，以后对接就交给这家子公司了，你又可以去接新的项目了。</p>
<p>这里有一个问题是，如何创建子公司，并如何将项目移交给子公司呢？</p>
<p>在 Linux 下，创建子进程使用 fork 函数。通过名字可以看出，这是在父进程的基础上完全拷贝一个子进程。在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程。显然，复制的时候在调用 fork，复制完毕之后，父进程和子进程都会记录当前刚刚执行完 fork。这两个进程刚复制完的时候，几乎一模一样，只是根据 fork 的返回值来区分到底是父进程，还是子进程。如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p>
<p>进程复制过程我画在这里。</p>
<p><img src="https://static001.geekbang.org/resource/image/d3/1c/d353eee3c387332e378c1e517c642f1c.jpg" alt="">  </p>
<p>因为复制了文件描述符列表，而文件描述符都是指向整个内核统一的打开文件列表的，因而父进程刚才因为 accept 创建的已连接 Socket 也是一个文件描述符，同样也会被子进程获得。</p>
<p>接下来，子进程就可以通过这个已连接 Socket 和客户端进行互通了，当通信完毕之后，就可以退出进程，那父进程如何知道子进程干完了项目，要退出呢？还记得 fork 返回的时候，如果是整数就是父进程吗？这个整数就是子进程的 ID，父进程可以通过这个 ID 查看子进程是否完成项目，是否需要退出。</p>
<h3 id="-">方式二：将项目转包给独立的项目组（多线程方式）</h3>
<p>上面这种方式你应该也能发现问题，如果每次接一个项目，都申请一个新公司，然后干完了，就注销掉这个公司，实在是太麻烦了。毕竟一个新公司要有新公司的资产，有新的办公家具，每次都买了再卖，不划算。</p>
<p>于是你应该想到了，我们可以使用<strong>线程</strong>。相比于进程来讲，这样要轻量级的多。如果创建进程相当于成立新公司，购买新办公家具，而创建线程，就相当于在同一个公司成立项目组。一个项目做完了，那这个项目组就可以解散，组成另外的项目组，办公家具可以共用。</p>
<p>在 Linux 下，通过 pthread_create 创建一个线程，也是调用 do_fork。不同的是，虽然新的线程在 task 列表会新创建一项，但是很多资源，例如文件描述符列表、进程空间，还是共享的，只不过多了一个引用而已。</p>
<p><img src="https://static001.geekbang.org/resource/image/ab/d7/ab6e0ecfee5e21f7a563999a94bd8bd7.jpg" alt="">
﻿
新的线程也可以通过已连接 Socket 处理请求，从而达到并发处理的目的。</p>
<p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程。一台机器无法创建很多进程或者线程。有个<strong>C10K</strong>，它的意思是一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，那么操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器，成本也太高了。</p>
<p>其实 C10K 问题就是，你接项目接的太多了，如果每个项目都成立单独的项目组，就要招聘 10 万人，你肯定养不起，那怎么办呢？</p>
<h3 id="-io-socket-">方式三：一个项目组支撑多个项目（IO 多路复用，一个线程维护多个 Socket）</h3>
<p>当然，一个项目组可以看多个项目了。这个时候，每个项目组都应该有个项目进度墙，将自己组看的项目列在那里，然后每天通过项目墙看每个项目的进度，一旦某个项目有了进展，就派人去盯一下。</p>
<p>由于 Socket 是文件描述符，因而某个线程盯的所有的 Socket，都放在一个文件描述符集合 fd_set 中，这就是<strong>项目进度墙</strong>，然后调用 select 函数来监听文件描述符集合是否有变化。一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的位都设为 1，表示 Socket 可读或者可写，从而可以进行读写操作，然后再调用 select，接着盯着下一轮的变化。。</p>
<h3 id="-io-">方式四：一个项目组支撑多个项目（IO 多路复用，从“派人盯着”到“有事通知”）</h3>
<p>上面 select 函数还是有问题的，因为每次 Socket 所在的文件描述符集合中有 Socket 发生变化的时候，都需要通过轮询的方式，也就是需要将全部项目都过一遍的方式来查看进度，这大大影响了一个项目组能够支撑的最大的项目数量。因而使用 select，能够同时盯的项目数量由 FD_SETSIZE 限制。</p>
<p>如果改成事件通知的方式，情况就会好很多，项目组不需要通过轮询挨个盯着这些项目，而是当项目进度发生变化的时候，主动通知项目组，然后项目组再根据项目进展情况做相应的操作。</p>
<p>能完成这件事情的函数叫 epoll，它在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数的方式，当某个文件描述符发送变化的时候，就会主动通知。</p>
<p><img src="https://static001.geekbang.org/resource/image/cf/19/cff688ede147809da4d65fe4152ffb19.jpg" alt="">  </p>
<p>如图所示，假设进程打开了 Socket m, n, x 等多个文件描述符，现在需要通过 epoll 来监听是否这些 Socket 都有事件发生。其中 epoll_create 创建一个 epoll 对象，也是一个文件，也对应一个文件描述符，同样也对应着打开文件列表中的一项。在这项里面有一个红黑树，在红黑树里，要保存这个 epoll 要监听的所有 Socket。</p>
<p>当 epoll_ctl 添加一个 Socket 的时候，其实是加入这个红黑树，同时红黑树里面的节点指向一个结构，将这个结构挂在被监听的 Socket 的事件列表中。当一个 Socket 来了一个事件的时候，可以从这个列表中得到 epoll 对象，并调用 call  back 通知它。</p>
<p>这种通知方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p>
<h2 id="-">小结</h2>
<p>好了，这一节就到这里了，我们来总结一下：</p>
<ul>
<li><p>你需要记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数；</p>
</li>
<li><p>写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决 C10K 问题。</p>
</li>
</ul>
<p>最后，给你留两个思考题：</p>
<ol>
<li><p>epoll 是 Linux 上的函数，那你知道 Windows 上对应的机制是什么吗？如果想实现一个跨平台的程序，你知道应该怎么办吗？</p>
</li>
<li><p>自己写 Socket 还是挺复杂的，写个 HTTP 的应用可能简单一些。那你知道 HTTP 的工作机制吗？</p>
</li>
</ol>
<p>欢迎你留言和我讨论。趣谈网络协议，我们下期见！</p>
<p><img src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg" alt=""></p>
</div></div> <!----> <div data-v-87ffcada="" class="copyright">
        ©版权归极客邦科技所有，未经许可不得转载
      </div></div> <div data-v-87ffcada="" class="switch-btns pd"><div data-v-87ffcada="" class="btn"><div data-v-87ffcada="" class="tag">上一篇</div> <div data-v-87ffcada="" class="txt">第12讲 | TCP协议（下）：西行必定多妖孽，恒心智慧消磨难</div></div> <div data-v-87ffcada="" class="btn"><div data-v-87ffcada="" class="tag">下一篇</div> <div data-v-87ffcada="" class="txt">第14讲 | HTTP协议：看个新闻原来这么麻烦</div></div></div> <div data-v-87ffcada="" class="to-comment pd"><a data-v-87ffcada="" class="button-primary">写留言</a></div> <div data-v-87ffcada="" class="article-comments pd"><h2 data-v-87ffcada=""><span data-v-87ffcada="">精选留言</span></h2> <ul data-v-87ffcada=""><li data-v-87ffcada="" class="comment-item"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erQaN1AkcKQJRTWRop4fLpf2Z2nt1SUk9quVmw3YzIuNGAwnjGoPjQ3kC3XOAPSpFaeG1haeYfhBg/132" class="avatar"> <div class="info"><div class="hd"><span class="username">time_qiao</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>65</span></a></div></div> <div class="bd">刘老师看完这节，觉得您的linux功底实在太深厚了，这个系列做完能不能做个linux系列的</div> <span class="time">2018-06-21</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/47/66/34b08bed.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">零一</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>16</span></a></div></div> <div class="bd">第一个问题，windows 上是 iocp，如果想跨平台，要么使用兼容性较好的 select，要么对不同的平台使用不同的调用，kqueue iocp等。<br>第二个问题，HTTP 是构建在 tcp 协议之上的，用 telnet 可以轻松构造一个 HTTP 请求</div> <span class="time">2018-06-15</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/a6/6b/12d87713.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">Jealone</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>11</span></a></div></div> <div class="bd">Epoll和IOCP还是有本质区别的，IOCP是封装了IO操作的，而epoll只是一个事件通知机制，意味着IOCP的IO操作也可以由内核完成，因此IOCP算异步IO，而基于epoll的仍然是同步IO，于IOCP相对应的不是epoll而是AIO</div> <span class="time">2018-06-15</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/29/72/76838c57.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">白杨</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>7</span></a></div></div> <div class="bd">我个人觉得还可以讲的更本质一些。<br>不论是同步还是异步，阻塞还是非阻塞，都是用某种方法创建了某种结构，而不同的是，是谁在执行内部的方法，是谁写了标志，是谁触发了事件，是谁在操作io，是谁在等待，是谁在返回。<br>换句话说就是，本来我在做的事情，让你来做吧，本来你在做的事情，让我来做吧。</div> <span class="time">2018-06-27</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/static/time/img/defaultAvatar.e4ab9fe.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">幻想</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>7</span></a></div></div> <div class="bd">真心写的好。多谢作者。</div> <span class="time">2018-06-15</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/e8/4d/e7728500.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">自然而然</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>4</span></a></div></div> <div class="bd">这篇写的很棒，很见功底</div> <span class="time">2018-07-21</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/f9/61/0f2e4328.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">灵魂胖子</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div></div> <div class="bd">老师，那个UDP 协议的 Socket 程序函数调用过程中的客户端可以不用调用bind（）吧?</div> <span class="time">2018-06-21</span> <div class="reply"><div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> <p class="reply-content">可以</p> <p class="reply-time">2018-06-21</p></div></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/static/time/img/defaultAvatar.e4ab9fe.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">大光头</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div></div> <div class="bd">windows上有一个叫iocp，但是它还是有点不一样，它是proactor，而epoll是reactor。我觉得iocp效率会更高，epoll通知应用去读取数据，处理完之后还要返回内核发送数据，而完成端口直接在内核态进行处理数据，最后告诉应用，数据已经处理完了。</div> <span class="time">2018-06-15</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/e5/40c4ef73.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">徐曹植</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div></div> <div class="bd">请问epoll监听机制是如何实现的呢？底层本质也是轮询吗？</div> <span class="time">2018-08-10</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/58/ab/86a51f0c.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">Hugo</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div></div> <div class="bd">老师监听的socket和已连接的socket 是每次连接两个都会创建 。      <br>还是监听的socket只创建一次   <br>每次都创建已连接的socket？</div> <span class="time">2018-06-25</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/20/5d/69170b96.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">灰灰</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div></div> <div class="bd">老师，对socket这块一直理解比较抽象，什么情况下需要socket编程，我印象中从来没写过。盼复</div> <span class="time">2018-06-19</span> <div class="reply"><div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> <p class="reply-content">很多地方啊，可能都是框架做好了，但是看框架的源代码，还是能看到的</p> <p class="reply-time">2018-06-19</p></div></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/44/94/835a2427.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">天</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div></div> <div class="bd">喜欢这种基于内核的分析，老师可以开一门socket内核分析的课程，从三次握手到网络通信，整个内核的流程分析，之前看过秦健老师的tcp内核追踪，但是年代比较久远，是基于2.6内核写的</div> <span class="time">2018-06-17</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">赵强强</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div></div> <div class="bd">老师，sk_buffer里面的数据应该是剔除掉链路层和网络层头部信息的吧?</div> <span class="time">2018-06-15</span> <div class="reply"><div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> <p class="reply-content">没有，内核代码就是这样的</p> <p class="reply-time">2018-06-15</p></div></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/4f/e7/7e51052a.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">fumeck.com🍋🌴summer sk...</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div></div> <div class="bd">每天上班路上阅读，很充实，对于菜鸟的我收益颇多</div> <span class="time">2018-06-15</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/dc/68/006ba72c.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">twelve</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div></div> <div class="bd">老师很形象地描述了线程和进程的区别，这个与操作系统上的cup工作机制的概念是一致的吗？</div> <span class="time">2018-09-16</span> <div class="reply"><div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> <p class="reply-content">就是操作系统的方式</p> <p class="reply-time">2018-09-16</p></div></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/b6/e7/bad852ba.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">汪木木</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div></div> <div class="bd">这就是几种网络io的由来，bio，nio1，nio2。</div> <span class="time">2018-07-20</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/static/time/img/defaultAvatar.e4ab9fe.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">星文友</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div></div> <div class="bd">select由文件描述fd_set限制<br>epoll 由文件描述符数量限制 <br>两个差异很大吗</div> <span class="time">2018-06-16</span> <div class="reply"><div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> <p class="reply-content">大，文件描述符更大，fdset小的多</p> <p class="reply-time">2018-06-16</p></div></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/28/1e/76e19bd3.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">张立春</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div></div> <div class="bd">几种方式写的逻辑清晰易懂，赞一个！</div> <span class="time">2018-06-15</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/9a/e6/be5d234b.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">ttxser</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div></div> <div class="bd">这篇写的真好<br></div> <span class="time">2018-11-02</span> <!----></div></li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/6f/63/8808cc00.jpg" class="avatar"> <div class="info"><div class="hd"><span class="username">扬～</span> <div class="control"><!----> <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div></div> <div class="bd">UDP的socket的调用过程中，为什么没有listen呢，要不应用程序怎么监听此端口？要不怎么把UDP的包发往监听此端口的应用程序呢？基于UDP的方式会不会因为连接数过多，造成服务器处理压力增大从而延迟增高呢？因为他们共用一个端口，而不是像TCP那样会复制一个套接字随机分配一个端口用于数据接受和发送。我不知道我说的对不对，希望老师能够解答一下困惑。</div> <span class="time">2018-11-02</span> <div class="reply"><div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> <p class="reply-content">udp没有状态，所以不存在监听这个状态，内存里没有保存连接的任何信息，不占用资源，所以不存在连接数过多的压力，顶多是把网卡打满</p> <p class="reply-time">2018-11-02</p></div></div></li></ul></div></div> <!----> <!----></div>
</body>
</html>